//-----------------------------------------------------------------------------
// File: Import3DS.cpp
//
// Desc: Code for importing 3D Studio models
//
// Copyright (c) 1999 William Chin. All rights reserved.
//-----------------------------------------------------------------------------
//
#include "StdAfx.h"
#include <windows.h>
#include <stdio.h>
#include <math.h>
#include "Import3DS.hpp"

int kf_count = 0;

short pt_flags;
short unknown;
unsigned long kfstart, kfend;
unsigned long kfcurframe;


BOOL command_found_flag;
BOOL loading_first_model_flag = TRUE;
BOOL bEnable3dsLogfile = FALSE;

	int num_materials = 0;
	int num_maps = 0;
	int total_num_frames = 1;

char material_list[MAX_NUM_3DS_TEXTURES][MAX_NAME_LENGTH];
char mapnames     [MAX_NUM_3DS_TEXTURES][MAX_NAME_LENGTH];

FILE *logfile;
FILE *fp_3dsmodel;



C3DS* pC3DS;  // global pointer to C3DS class

// class constructor
C3DS::C3DS()
{
	pC3DS = this;
}


bool C3DS::Import3DS(char *filename, int num_obj)
{

	FILE *fp; 
	FILE *fp_3dsmodel;
	FILE *rrlogfile;
	int done;
	int i,j,cnt;
	int length;
	int	data_length;
	int frame_num;
	int num_frames;
	int datfile_vert_cnt;
	int quad_cnt=0;
	unsigned short	command;
	char temp;
	float tx, ty, tz;
	float angle;
	float x,y,z;
	BOOL process_data_flag;
	char datfilename[1024];
	int file_ex_start = 0;

	num_materials = 0;
	num_maps = 0;
	total_num_frames = 1;
	num_trimesh = 0;

	num_parts = 0;

	kf_count = -1;
	total_num_faces = 0;
	total_num_verts = 0;
	last_num_faces = 0;
	last_num_verts = 0;
	num_maps = 0;
	num_materials = 0;
	last_num_mcoords = 0; 
	total_num_mcoords = 0;
	num_materials = 0;

	fp = fopen(filename, "rb");


	logfile = fopen("3dslogfile.txt", "w"); 
	
	if(bEnable3dsLogfile)
	{
		fprintf(logfile, "3DS Logfile generated by D3DS viewer\n");
		fprintf(logfile, "3DS Model filename %s\n\n", filename);
	}


	done = 0;

	while (done == 0)
	{
		process_data_flag  = FALSE;
		command_found_flag = FALSE;

		fread(&command, sizeof(command), 1, fp);
		
		// Test for end of file

		if (feof(fp))
		{
			done = 1;
			break;
		}
		
		fread (&length, sizeof(length), 1, fp);
		data_length = length - 6;

		// Process 3DS file commands


		switch (command)
		{
			case TRIANGLE_MESH:
				num_trimesh++;
				PrintLogFile(logfile, "TRIANGLE_MESH");
				process_data_flag = TRUE;	
			break;

			case TRIANGLE_VERTEXLIST: 
				if(ProcessVertexData(fp) == TRUE)
					process_data_flag = TRUE;
			break;

			case TRIANGLE_FACELIST: 
				if(ProcessFaceData(fp) == TRUE)
					process_data_flag = TRUE;
			break;
			
			case TRIANGLE_MAPPINGCOORS:
				ProcessMappingData(fp);
				process_data_flag = TRUE;
			break;

			case TRIANGLE_MATERIAL:
				ProcessMaterialData(fp);
				process_data_flag = TRUE;
			break;

			case EDIT_MATERIAL: 
				PrintLogFile(logfile, "\nEDIT_MATERIAL");	
				process_data_flag = TRUE;
			break;

			case MAT_NAME01:
				AddMaterialName(fp);
				process_data_flag = TRUE;
			break;

			case TEXTURE_MAP:
				PrintLogFile(logfile, "TEXTURE_MAP");	
				process_data_flag = TRUE;
			break;
				
			case MAPPING_NAME:
				AddMapName(fp);
				process_data_flag = TRUE;
			break;
			
			case MAIN3DS:
				PrintLogFile(logfile, "MAIN3DS");
				process_data_flag = TRUE;	
			break;

			case EDIT3DS:
				PrintLogFile(logfile, "EDIT3DS");
				process_data_flag = TRUE;	
			break;


			case KEYFRAME:
				PrintLogFile(logfile, "\n\nKEYFRAME");
				process_data_flag = TRUE;
			break;
			
			case KEYFRAME_MESH_INFO:
				PrintLogFile(logfile, "\nKEYFRAME_MESH_INFO");
				kf_count++;
				process_data_flag = TRUE;	
			break;

			case KEYFRAME_START_AND_END:
				PrintLogFile(logfile, "KEYFRAME_START_AND_END");
				fread(&kfstart, sizeof(unsigned long), 1, fp);
				fread(&kfend,	sizeof(unsigned long), 1, fp);
				process_data_flag = TRUE;	
			break;
				
			case KEYFRAME_HEADER:
				PrintLogFile(logfile, "KEYFRAME_HEADER");
				process_data_flag = TRUE;	
			break;

			case KFCURTIME:
				fread(&kfcurframe, sizeof(long), 1, fp);
				if(bEnable3dsLogfile)
					fprintf(logfile, "KFCURTIME  %d\n", kfcurframe);
				process_data_flag = TRUE;	
			break;

			case PIVOT:
				ProcessPivots(fp);
				process_data_flag = TRUE;	
			break;

			case POS_TRACK_TAG:  
				ProcessPositionTrack(fp);
				process_data_flag = TRUE;	
				break;

			case ROT_TRACK_TAG:  
				ProcessRotationTrack(fp);
				process_data_flag = TRUE;	
				break;
		
			case SCL_TRACK_TAG:
				ProcessScaleTrack(fp);
				process_data_flag = TRUE;	
				break;
			
			case NODE_HDR:
				ProcessNodeHeader(fp);
				process_data_flag = TRUE;	
				break;

			case NODE_ID:
				ProcessNodeId(fp);
				process_data_flag = TRUE;	
				break;
				

			case M3DS_VERSION:
				Process3DSVersion(fp);
				process_data_flag = TRUE;
				break;

			case TRIANGLE_SMOOTH:
				PrintLogFile(logfile, "TRIANGLE_SMOOTH");
				ProcessTriSmoothData(fp);
				process_data_flag = TRUE;	
			break;

			case TRI_LOCAL:
				PrintLogFile(logfile, "TRI_LOCAL");
				ProcessTriLocalData(fp);
				process_data_flag = TRUE;	
			break;

		} 


	
	int v, pos_keys, v_start, v_end;


/*	for(v = 0; v < total_num_verts; v++)
		{
			Object.fverts[v][0] -= Object.pivot.x; 
			Object.fverts[v][1] -= Object.pivot.y;
			Object.fverts[v][2] -= Object.pivot.z;
		}
*/	}
	


	return true;
}

void C3DS::ProcessTriSmoothData(FILE *fp)
{
	int i, num_faces;
	BYTE a,b,c,d;


	num_faces = num_faces_in_object;

	for(i = 0;  i < num_faces; i++)
	{
		fread(&a, sizeof(BYTE), 1, fp);
		fread(&b, sizeof(BYTE), 1, fp);
		fread(&c, sizeof(BYTE), 1, fp);
		fread(&d, sizeof(BYTE), 1, fp);

		if(bEnable3dsLogfile)
			fprintf(logfile, " a,b,c,d : %d %d %d %d\n", a, b, c, d);
	}
}

void C3DS::ProcessTriLocalData(FILE *fp)
{
	float x,y,z;
	float local_centre_x, local_centre_y, local_centre_z;


	fread(&x, sizeof(float), 1, fp);
	fread(&y, sizeof(float), 1, fp);
	fread(&z, sizeof(float), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, " x,y,z: %f %f %f\n", x, y, z);
		
	fread(&x, sizeof(float), 1, fp);
	fread(&y, sizeof(float), 1, fp);
	fread(&z, sizeof(float), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, " x,y,z: %f %f %f\n", x, y, z);
	
	fread(&x, sizeof(float), 1, fp);
	fread(&y, sizeof(float), 1, fp);
	fread(&z, sizeof(float), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, " x,y,z: %f %f %f\n", x, y, z);
	
	fread(&local_centre_x, sizeof(float), 1, fp);
	fread(&local_centre_y, sizeof(float), 1, fp);
	fread(&local_centre_z, sizeof(float), 1, fp);

	if(bEnable3dsLogfile)
	{
		fprintf(logfile, " local_centre_x,y,z : %f %f %f\n", 
			local_centre_x, local_centre_y, local_centre_z);
	}
	
	Object.local_centre_x = local_centre_x;
	Object.local_centre_y = local_centre_y;
	Object.local_centre_z = local_centre_z;
}



// PROCESS TEXTURE, MATERIAL, AND MAPPING DATA ROUTINES

void C3DS::AddMapName(FILE *fp)
{
	int	i; 
	BOOL error = TRUE;
	char map_name[256];

	// read in map name from file

	for (i = 0; i < 256; i++)
	{
		fread(&map_name[i], sizeof(char), 1, fp);
		if(map_name[i] == 0)
			break;
	}

	// remove file extention from string

	for (i = 0; i < 256; i++)
	{	
		if(map_name[i] == '.')
		{
			map_name[i] = 0;
			break;
		}
	}

		// lookup texture alias
/*
	for (i = 0; i < 100; i++)
	{	
		if(strcmpi(map_name, pCMyApp->TexMap[i].tex_alias_name) == 0)
		{
			pCMyApp->pmdata[pmodel_id].texture_maps[num_maps] = i;
			error = FALSE;
			break;
		}
	}
*/
	strcpy(mapnames[num_maps], map_name);
	if(bEnable3dsLogfile)
		fprintf(logfile, "%s %s\n", "MAPPING_NAME ", mapnames[num_maps]); 
	num_maps++;

}

void C3DS::AddMaterialName(FILE *fp)
{	
	int	i; 
	BOOL error = TRUE;
	char mat_name[256];

	for (i = 0; i < 256; i++)
	{
		fread(&mat_name[i], sizeof(char), 1, fp);
		if(mat_name[i] == 0)
		{
			error = FALSE;
			break;
		}
	}

	if(bEnable3dsLogfile)
		fprintf(logfile,"MAT_NAME01  %s\n",mat_name);
	strcpy(material_list[num_materials], mat_name) ;
	num_materials++;
}

void C3DS::ProcessMaterialData(FILE *fp)
{
	int	i; 
	short findex, current_texture;
	unsigned short num_faces;
	BOOL error = TRUE;
	char mat_name[256];


	for (i = 0; i < 256; i++)
	{
		fread(&mat_name[i], sizeof(char), 1, fp);
		if(mat_name[i] == 0)
			break;
	}

	for (i = 0; i < MAX_NUM_3DS_TEXTURES; i++)
	{
		if(strcmpi(mat_name, material_list[i]) == 0)
		{
//			current_texture = pCMyApp->pmdata[pmodel_id].texture_maps[i];
			error = FALSE;
			break;
		}
	}

	fread(&num_faces, sizeof(num_faces), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, "TRIANGLE_MATERIAL %d\n", num_faces);

	for (i = 0; i < num_faces; i++)
	{
		fread(&findex, sizeof(short), 1, fp);
		Object.faces[last_num_faces + findex].tex = current_texture;
	}
	return;
}

void C3DS::ProcessMappingData(FILE *fp)
{
	int	i; 
	unsigned short num_mapping_coords;
	
	total_num_mcoords = last_num_verts;

	fread(&num_mapping_coords, sizeof(num_mapping_coords), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, "%s %d\n", "TRIANGLE_MAPPINGCOORS ", num_mapping_coords);

	for (i = 0; i < num_mapping_coords; i++)
	{
		fread(&Object.mcoords[total_num_mcoords].x, sizeof(float), 1, fp);
		fread(&Object.mcoords[total_num_mcoords].y, sizeof(float), 1, fp);

		if(bEnable3dsLogfile)
		{
			fprintf(logfile, " %f %f\n", 
				Object.mcoords[total_num_mcoords].x,
				Object.mcoords[total_num_mcoords].y);
		}
		total_num_mcoords++;
	}
	return;
}



// KEYFRAME - PROCESS ANIMATION DATA ROUTINES

void C3DS::ProcessPivots(FILE *fp)
{
	float x,y,z;
	
	fread(&x, sizeof(float), 1, fp);
	fread(&y,  sizeof(float), 1, fp);
	fread(&z,  sizeof(float), 1, fp);

	Object.pivot.x = x;
	Object.pivot.y = y;
	Object.pivot.z = z;

	if(bEnable3dsLogfile)
		fprintf(logfile, "PIVOT: %f %f %f\n", x, y, z);	

	
}

void C3DS::ProcessRotationTrack(FILE *fp)
{		
	int i;
	short framenum;
	long lunknown; 
	float rotation_rad;
	float axis_x;
	float axis_y;
	float axis_z;



	fread(&pt_flags, sizeof(short), 1, fp);

	fread(&unknown,  sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);

	fread(&Object.rotkeys,	 sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);
	
	if(bEnable3dsLogfile)
		fprintf(logfile, "ROT_TRACK_TAG %d\n", Object.rotkeys);
	
	for(i = 0; i < Object.rotkeys; i++)
	{
		fread(&framenum,  sizeof(short), 1, fp);
		fread(&lunknown,  sizeof(long), 1, fp);
		fread(&rotation_rad,  sizeof(float), 1, fp);
		fread(&axis_x,  sizeof(float), 1, fp);
		fread(&axis_y,  sizeof(float), 1, fp);
		fread(&axis_z,  sizeof(float), 1, fp);

		if(bEnable3dsLogfile)
		{
			fprintf(logfile, " framenum = %d  rot_angle/rads = %f  axis_x,y,z : %f %f %f\n", 
			              framenum, rotation_rad, axis_x, axis_y, axis_z);	
		}

		if(i < total_num_frames)
		{
			Object.rot_track[i].framenum = framenum;
			Object.rot_track[i].lunknown = lunknown;
			Object.rot_track[i].rotation_rad = rotation_rad;
			Object.rot_track[i].axis_x = axis_x;
			Object.rot_track[i].axis_y = axis_y;
			Object.rot_track[i].axis_z = axis_z;
		}
	}

}

void C3DS::ProcessPositionTrack(FILE *fp)
{	
	
	int i;
	short framenum;
	long  lunknown;
	float pos_x;
	float pos_y;
	float pos_z;


	
	fread(&pt_flags, sizeof(short), 1, fp);

	fread(&unknown,  sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);

	fread(&Object.poskeys,	 sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);
	
	if(bEnable3dsLogfile)
		fprintf(logfile, "POS_TRACK_TAG %d\n", Object.poskeys);
	
	for(i = 0; i < Object.poskeys; i++)
	{
		fread(&framenum,  sizeof(short), 1, fp);
		fread(&lunknown,  sizeof(long), 1, fp);
		fread(&pos_x,  sizeof(float), 1, fp);
		fread(&pos_y,  sizeof(float), 1, fp);
		fread(&pos_z,  sizeof(float), 1, fp);

		if(bEnable3dsLogfile)
		{
			fprintf(logfile, " framenum = %d   pos_x,y,z : %f %f %f\n", 
			              framenum, pos_x, pos_y, pos_z);
		}

		if(i < total_num_frames)
		{
			//fprintf(logfile, "i: %d   total_num_frames: %d\n", 
			  //                i, total_num_frames);	

			Object.pos_track[i].framenum = framenum;
			Object.pos_track[i].lunknown = lunknown;
			Object.pos_track[i].pos_x = pos_x;
			Object.pos_track[i].pos_y = pos_y;
			Object.pos_track[i].pos_z = pos_z;
		}
	}
}
	
void C3DS::ProcessScaleTrack(FILE *fp)
{	
	
	int i;
	short framenum;
	long lunknown;		
	float scale_x;
	float scale_y;
	float scale_z;


	fread(&pt_flags, sizeof(short), 1, fp);

	fread(&unknown,  sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);

	fread(&Object.sclkeys,	 sizeof(short), 1, fp);
	fread(&unknown,  sizeof(short), 1, fp);
	
	if(bEnable3dsLogfile)
		fprintf(logfile, "SCL_TRACK_TAG %d\n", Object.sclkeys);
	
	for(i = 0; i < Object.sclkeys; i++)
	{
		fread(&framenum,  sizeof(short), 1, fp);
		fread(&lunknown,  sizeof(long), 1, fp);
		
		fread(&scale_x,  sizeof(float), 1, fp);
		fread(&scale_y,  sizeof(float), 1, fp);
		fread(&scale_z,  sizeof(float), 1, fp);

		if(bEnable3dsLogfile)
		{
			fprintf(logfile, " framenum = %d   x,y,z : %f %f %f\n", 
				framenum, scale_x, scale_y, scale_z);	
		}

	}
}

void C3DS::ProcessNodeId(FILE *fp)
{
	short node_id;


	fread(&node_id, sizeof(short), 1, fp);
	if(bEnable3dsLogfile)
		fprintf(logfile, "NODE_ID  %d\n", node_id); 
}

void C3DS::ProcessNodeHeader(FILE *fp)
{
	int i;
	short flags1, flags2, heirarchy;
	char node_name[256];


	// read in node name from file

	for (i = 0; i < 256; i++)
	{
		fread(&node_name[i], sizeof(char), 1, fp);
		if(node_name[i] == 0)
			break;
	}

	fread(&flags1, sizeof(short), 1, fp);
	fread(&flags2, sizeof(short), 1, fp);
	fread(&heirarchy, sizeof(short), 1, fp);

	if(bEnable3dsLogfile)
	{
		fprintf(logfile, "NODE_HDR %s\n", node_name);
		fprintf(logfile, " flags1 %d\n", flags1);
		fprintf(logfile, " flags2 %d\n", flags2);
		fprintf(logfile, " heirarchy %d\n", heirarchy);
	}

}

void C3DS::Process3DSVersion(FILE *fp)
{
	short version;

	fread(&version, sizeof(short), 1, fp);
	if(bEnable3dsLogfile)
		fprintf(logfile, "3DS VERSION %d\n",version);
	fread(&version, sizeof(short), 1, fp);
}

void C3DS::ProcessMasterScale(FILE *fp)
{
	float master_scale;

	fread(&master_scale, sizeof(float), 1, fp);
	if(bEnable3dsLogfile)
		fprintf(logfile, "MASTER_SCALE %f\n",master_scale);	
}

// RELEASE AND DEBUG ROUTINES

void C3DS::ReleaseTempMemory()
{
	
}

void C3DS::PrintLogFile(FILE *logfile, char *commmand)
{
	if(bEnable3dsLogfile)
	{
		fprintf(logfile, commmand);
		fprintf(logfile,"\n");
	}
	command_found_flag = TRUE;
}




BOOL C3DS::ProcessVertexData(FILE *fp)
{
	int	i, j ;
	int temp_int;
	float p, temp_float;
	unsigned short num_vertices;

	last_num_verts = total_num_verts;
	Object.verts_start = total_num_verts;
	
	fread(&num_vertices, sizeof(num_vertices), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, "%s %d\n", "TRIANGLE_VERTEXLIST", num_vertices);

	if((total_num_verts + num_vertices) >= MAX_NUM_3DS_VERTICES)
		return FALSE;
			
	for (i = 0; i < (int)num_vertices; i++)
	{
		for (j = 0; j < 3; j++)
		{
			fread(&p, sizeof(float), 1, fp);
			temp_int = (int)( ((p * (float)10000) + (float)0.5));
			temp_float = (float)temp_int / (float)10000;
			Object.fverts[i+total_num_verts][j] = temp_float;
		}

		// set default mapping co-ordinates, in case none are defined in model
		Object.mcoords[i+total_num_verts].x = 0;
		Object.mcoords[i+total_num_verts].y = 0;

	}	

	total_num_verts += num_vertices;

	Object.verts_end = total_num_verts - 1;
	
	Object.num_verts_in_parts[num_parts] = num_vertices;

	num_parts++;

	return TRUE;
}


BOOL C3DS::ProcessFaceData(FILE *fp)
{

	int	i, j, cnt = 0;
	unsigned short num_faces, face_index, ftemp;

	last_num_faces = total_num_faces;

	fread(&num_faces, sizeof(num_faces), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, "%s %d\n", "TRIANGLE_FACELIST ", num_faces);

	num_faces_in_object = (short)num_faces;

	if((total_num_faces + num_faces) >= MAX_NUM_3DS_FACES)
		return FALSE;
			

	for (i = 0; i < (int)num_faces; i++)
	{
		for (j = 0; j < 4; j++)
		{
			fread(&face_index, sizeof(face_index), 1, fp);
			
			// note faces 1 to 3 are valid face indices, but the 4th one is NOT
			if(j < 3)
			{
				ftemp = (unsigned short)(face_index);// + last_num_verts);
				Object.faces[total_num_faces].v[j] = ftemp;
				if(bEnable3dsLogfile)
					fprintf(logfile, " %d", face_index);
			}
			else
			{
				if(bEnable3dsLogfile)
				{
					fprintf(logfile, "   flags: %d => ", face_index);

					if((face_index & 0x0001) == 0x0001) 
						fprintf(logfile, "  AC: 1");
					else
						fprintf(logfile, "  AC: 0");


					if((face_index & 0x0002) == 0x0002) 
						fprintf(logfile, "  BC: 1");
					else
						fprintf(logfile, "  BC: 0");


					if((face_index & 0x0004) == 0x0004) 
						fprintf(logfile, "  AB: 1");
					else
						fprintf(logfile, "  AB: 0");
				}
			}
		}
		total_num_faces++;
		if(bEnable3dsLogfile)
			fprintf(logfile, "\n");
	}
	
	return TRUE;
}
